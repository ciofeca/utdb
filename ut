#!/usr/bin/env ruby

# --- configuration -----------------------------------------------------------
#
UT_DIR=ENV['HOME']+'/Desktop/urbanterror'
UT_EXE='Quake3-UrT.x86_64'
UT_USR='acciuga'                        # my real screen name when console says "You"
UT_UNP='/tmp/ut.log'                    # unparsed console messages log file, or /dev/null

# --- utilities ---------------------------------------------------------------
#
class String
  def fetch
    split(/\^/)[1].strip[1..-1]         # shortcut for most console lines
  end
end

class Integer
  def sanitize min, max
    return min  if self < min
    return max  if self > max
    self
  end

  def perc                              # prettyprint a 0-1000 value as a 0.0%-100.0% string
    "#{self/10}.#{self%10}%"
  end

  def ratio n                           # prettyprint a 1:n or n:1 ratio, if nonzeros
    return "0:#{n}"  if self == 0
    return "#{self}:0"  if n == 0
    r = if self < n
          (n * 100.0 / self).floor / 100.0
        else
          (self * 100.0 / n).floor / 100.0
        end.to_s
    self < n ? "1:#{r}" : "#{r}:1"
  end
end


require 'pg'

class PGconn
  # pump up an event to database table
  #
  def upsert usr, newset, increm = [], incrval = 1
    return  if usr.size < 3

    sql1 = "insert into ut  (name, lastseen"
    sql2 = ")  values ('#{escape_string usr}', to_timestamp(#{Time.now.to_f})"
    sql3 = ")  on conflict (name) do update set  lastseen = to_timestamp(#{Time.now.to_f})"
    sql4 = "  where ut.name = '#{escape_string usr}';"

    if newset != []                     # single value to be initialized?
      sql1 += ", #{newset.first}"
      sql2 += ", '#{escape_string newset.last}'"
      sql3 += ", #{newset.first} = '#{escape_string newset.last}'"
    end

    increm.each do |fld|                # numeric fields to be initialized or incremented
      sql1 += ", #{fld}"
      sql2 += ", #{incrval}"
      sql3 += ", #{fld} = ut.#{fld} + #{incrval}"
    end

    sql = sql1 + sql2 + sql3 + sql4

    begin
      exec sql                          # should only crash in case of oversized varchars
    rescue PG::Error => e
      STDERR.puts "FAILED: #{sql}"
      STDERR.puts "#{e}"
      fail "cannot ignore errors"
    end
  end

  # select up to lim ordered rows, possibly with "where" clause and optional "limit"
  #
  def select fields, whe=nil, ord=nil, lim=nil
    ord = "order by #{ord}"  if ord
    lim = "limit #{lim}"  if lim
    whe = "where location != 'None'"  unless whe
    sql = "select #{fields.join ', '}  from ut  #{whe}  #{ord}  #{lim}".strip

    #STDERR.puts "#{Time.now.strftime '%T'}  debug:  #{sql}"
    exec sql
  end

  # 'humans' count
  #
  def count
    exec("select count(*)  from ut  where location != 'None'").first['count'].to_i
  end

  # output stats (query a few fields, apply optional extra field and where-clause)
  #
  def stats desc, ordby, extra='', wher=''
    fields = %w{ name location killed killedme hit hitme damage damageme rekt rektme kills deaths lastseen }
    fields += [ extra ]  if extra != ''
    nme = select fields, "where name != '#{UT_USR}' and location != 'None' #{wher}", ordby, 30

    return  if nme.ntuples < 1                  # don't bother if no rows selected

    puts
    puts "%-62s%s" % [ "#{desc}:", "killed killedme hit hitme damage damageme rekt rektme kills deaths     last seen on" ]
    nme.values.each_with_index do |elem, i|
      puts "%2d) %-24.24s %-32s %6d %8d %3d %5d %6d %8d %4d %6d %5d %6d  %-16.16s" % ([ i+1 ] + elem)
    end
  end
end


# --- main --------------------------------------------------------------------
#

db = PGconn.new
db.exec "set client_min_messages to warning;   -- don't complain if table already exists
         create table if not exists
         ut (name      varchar(20) unique,     -- screen name
             account   varchar(32) default '', -- if reported, was guaranteed to be unique
             location  varchar(32) default '', -- if 'None' it's a bot
             firstseen timestamptz default current_timestamp,
             lastseen  timestamptz default current_timestamp,
             kills     integer     default 0,  -- player overall score
             deaths    integer     default 0,  -- player overall shame
             killed    integer     default 0,  -- times I killed this player
             killedme  integer     default 0,  -- times I got killed by this player
             hit       integer     default 0,  -- times I hit this player
             hitme     integer     default 0,  -- times I got hit by this player
             damage    integer     default 0,  -- sum of damages I inflicted to this player
             damageme  integer     default 0,  -- sum of damages I got inflicted by
             rekt      integer     default 0,  -- times I inflicted 100% damage hit
             rektme    integer     default 0,  -- times I got 100% damage by a single hit
             spree     integer     default 0,  -- player 'killing spree' events
             lemming   integer     default 0,  -- suicides by jumping or drowning
             grenade   integer     default 0,  -- suicides by stepping on own grenade
             kicked    integer     default 0,  -- punishments, idle-logouts, bot disabling
             smitten   integer     default 0); -- punishments by server administrators;
	 insert into ut (name) values ('#{UT_USR}') on conflict (name) do update set lastseen = to_timestamp(#{Time.now.to_f})"

# start the game and popen its console:
#
start, k, d, i, g = Time.now, 0, 0, 0, 0
logfile = open(UT_UNP, 'a')
fp = ARGV.first == '-' ? STDIN : IO.popen("cd #{UT_DIR}; ./#{UT_EXE} +exec autoexec.cfg 2>&1")
lines, upserts = 0, 0

# parse and dispatch loop
#
fp.each_line do |lin|
  lines += 1
  c = lin.chomp
  case c
  when /7connected from /
    loc = $'.chomp
    usr = c.split(/ \^7/)[1]
    db.upsert usr, [ 'location', loc ], []

  when /\^. joined the battle/
    usr = $`
    db.upsert usr, [], []

  when / account: \^.\^./
    c = c.split("[auth] ^7")[1].split("^7")
    usr = c.first
    db.upsert usr, [ 'account', c[4] ], []

  when / did the lemming thing/, / with fishes/
    usr = c.fetch
    db.upsert usr, [], [ 'deaths', 'lemming' ]

  when /'Sploded\./
    db.upsert UT_USR, [], [ 'deaths', 'grenade' ]

  when / stepped on h.. own grenade/
    usr = c.fetch
    db.upsert usr, [], [ 'deaths', 'grenade' ]

  when / has been killed by \^./
    usrkiller = $'.chomp
    usrkilled = c.fetch
    usrkiller = usrkiller.sub("^7^7.",'')
    db.upsert usrkiller, [], [ 'kills' ]
    db.upsert usrkilled, [], [ 'deaths' ]

  when /^You killed /
    usr = c.fetch
    k += 1
    db.upsert UT_USR, [], [ 'kills' ]
    db.upsert usr, [], [ 'deaths', 'killed' ]

  when /^You have been killed by /
    usr = c.fetch
    d += 1
    db.upsert UT_USR, [], [ 'deaths' ]
    db.upsert usr, [], [ 'kills', 'killedme' ]
    upserts += 1

  when /^.You hit \^/
    usr = c.fetch
    dam = c.split[-2].to_i.sanitize(1,100)
    i += dam
    db.upsert usr, [], [ 'hit' ]
    db.upsert usr, [], [ 'damage' ], dam
    upserts += 1
    if dam == 100
      db.upsert usr, [], [ 'rekt' ]
      upserts += 1
    end

  when /^.You were hit /
    usr = c.fetch
    dam = c.split[-2].to_i.sanitize(1,100)
    g += dam
    db.upsert usr, [], [ 'hitme' ]
    db.upsert usr, [], [ 'damageme' ], dam
    upserts += 1
    if dam == 100
      db.upsert usr, [], [ 'rektme' ]
      upserts += 1
    end

  when /\^7 was kicked$/, /Dropped due to inactivity$/
    usr = c.split("^").first
    db.upsert usr, [], [ 'kicked' ]

  when / was struck down /, /SMITTEN/
    usr = c.fetch
    db.upsert usr, [], [ 'smitten' ]

  when /7is on a killing spree /
    usr = c.fetch
    db.upsert usr, [], [ 'spree' ]
  else
    logfile.puts "#{Time.now.strftime '%Y%m%d:%H%M%S.%L'}  #{lin.chomp}"  # unparsed
    next
  end

  #logfile.puts "#{Time.now.strftime '%Y%m%d:%H%M%S.%L'}> #{lin.chomp}"   # parsed
  upserts += 1
end

# a few final statistics...
#
t = (Time.now - start).to_i/6
puts
db.stats "toughest human enemies ordered by max received damage", "damageme desc", '', "and damageme>0"
db.stats "toughest Italian enemies ordered by max received damage", "damageme desc", '', "and location='Italy (IT)' and damageme>0"
db.stats "toughest human enemies ordered by total kills", "killedme desc", '', "and killedme>0"
db.stats "suspected aimbot (cheating users)", "ratio desc", "rektme/killedme as ratio", "and killedme>0 and rektme>=10"
db.stats "human enemies I slayed more (by kill ratio)", "ratio desc", "(killed*100.0/(greatest(1,killedme))) as ratio", "and (killed+killedme)>=10 and killed>killedme"
db.stats "latest human enemies report", "lastseen desc", '', "and (damage+damageme) != 0 and lastseen >= (current_timestamp - interval '3 hours')"

puts
# you've been watching/camping too much if you get a low percentage of updates...
puts "summary out of #{lines} console events, #{upserts} database updates (#{(upserts*1000/lines).perc}):"

puts
puts "wasted time: #{t/10}.#{t%10} min --- #{k} kills, #{d} deaths (#{k.ratio d}) --- #{i}% inflicted, #{g}% got (#{i.ratio g})"

overall = %w{ killed killedme hit hitme damage damageme lemming grenade }
o = (db.select(overall.collect { |i| "sum(#{i}) as #{i}" }).first).
    merge(db.select(%w{ lemming grenade }, "where name='#{UT_USR}'").first).
    collect { |key,val| val.to_i }
puts
puts "overall personal score vs #{db.count} humans:"
puts "%24s %s" % [ "#{o[0]}:#{o[1]} kills   ", "(#{o[0].ratio o[1]})" ]
puts "%24s %s" % [ "#{o[2]}:#{o[3]} hits    ", "(#{o[2].ratio o[3]})" ]
puts "%24s %s" % [ "#{o[4]/1000}k:#{o[5]/1000}k damage% ", "(#{o[4].ratio o[5]})" ]
puts "%24s (%s)" % [ "#{o[6]}+#{o[7]} suicides", o[1]<1 ? "arrrgh" : ((o[6]+o[7])*1000 / o[1]).perc ]

o[0] = 1  if o[0] == 0
o[1] = 1  if o[1] == 0
dkr, dkrme = o[4]*10/o[0], o[5]*10/o[1]
# a good player has dkr>100% (the higher the better), dkrme approximately 100% (the higher the worse)
puts "%24s -- %s" % [ "#{dkr.perc} damage/kill ratio", "#{dkrme.perc} damaged/killed ratio" ]
puts
